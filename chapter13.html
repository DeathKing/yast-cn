<!doctype html>
<html lang="zh_CN">
<head>
	<meta charset="utf-8" />
	<title>第 13 章 关联表和哈希表</title>
    <meta name="author" content="DeathKing" />
    <link rel="stylesheet" href="style.css" />
</head>

<body>

<div class="entry">
<div class="container">
		
<div class="item chapter">
	<h1 id="chapter-13"><span>第 13 章</span> 关联表和哈希表</h1>
	<ol class="toc">          <li class="level-2">
            <a href="#section-13-1">13.1 简介</a>
          </li>
          <li class="level-2">
            <a href="#section-13-2">13.2 关联表</a>
          </li>
          <li class="level-2">
            <a href="#section-13-3">13.3 哈希表</a>
          </li>
          <li class="level-2">
            <a href="#section-13-4">13.4 生成密码</a>
          </li>
          <li class="level-3">
            <a href="#section-13-4-1">13.4.1 stat-spell.scm</a>
          </li>
          <li class="level-3">
            <a href="#section-13-4-2">13.4.2 make-pw.scm</a>
          </li>
          <li class="level-2">
            <a href="#section-13-5">13.5 总结</a>
          </li>
</ol>
  	<div class="main">
  		<h2 id='section-13-1'><span>13.1</span> 简介</h2>


<p>本章中，我会讲解用于表示数据关联的关联表和哈希表。关联的数据是由键和值组成的序对，值由键唯一确定的。表1显示了书和作者构成的配对。书籍可以确定作者，反之由作者确定书籍则不可，这是因为一个作者可能会写很多本书。表1中，由于P. Graham和L.Carroll分别写了两本书，因此他们的书无法被作者的名字唯一确定。</p>

<p>表1：作者和书</p>

<div class="table"><table>
  <thead>
    <tr>
      <th style="text-align: left">Author</th>
      <th style="text-align: left">Book</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">P. Graham</td>
      <td style="text-align: left">On Lisp</td>
    </tr>
    <tr>
      <td style="text-align: left">P. Graham</td>
      <td style="text-align: left">ANSI Common Lisp</td>
    </tr>
    <tr>
      <td style="text-align: left">E. S. Raymond</td>
      <td style="text-align: left">The Cathedral and the Bazaar</td>
    </tr>
    <tr>
      <td style="text-align: left">K. Dybvig</td>
      <td style="text-align: left">The Scheme Programming Language</td>
    </tr>
    <tr>
      <td style="text-align: left">F. P. Brooks, Jr.</td>
      <td style="text-align: left">The Mythical Man-Month</td>
    </tr>
    <tr>
      <td style="text-align: left">L. Carroll</td>
      <td style="text-align: left">Alice’s Adventures in Wonderland</td>
    </tr>
    <tr>
      <td style="text-align: left">L. Carroll</td>
      <td style="text-align: left">Through the Looking-Glass, and What Alice Found There</td>
    </tr>
  </tbody>
</table>
</div>
<p>R5RS定义了关联表，因此它在所有Scheme实现中都可用。但是使用关联表搜索速度较慢（O(n)的时间复杂度）。使用哈希表在速度方面更好一些（O(1)的时间复杂度），但是哈希表并未在R5RS中定义而是依赖于相关实现。MIT-Scheme实现了哈希表。如果你喜欢的Scheme实现没有哈希表，你可以自己实现一个（见 <a href="http://www.math.grin.edu/~stone/events/scheme-workshop/hash-tables.html">http://www.math.grin.edu/~stone/events/scheme-workshop/hash-tables.html</a>）。</p>

<h2 id='section-13-2'><span>13.2</span> 关联表</h2>


<p>关联表是一个由序对组成的表，它是一个用于表达关联的基本数据类型。符号，字符，和数字常被作为键使用，因为它们可以使用诸如eq?或者eqv?的快速比较函数被比较。在作为键被使用前，字符串应该被转换为符号，从而获得更好的性能。</p>

<p>下面是一个关联表的例子。关联表应该要么由点序对要么由普通表组成。</p>

<div class="codeblock"><div class="highlight type-scheme"><pre><span class="o">'</span><span class="p">((</span><span class="nf">hi</span> <span class="o">.</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nf">everybody</span> <span class="o">.</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="nf">nice</span> <span class="o">.</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nf">to</span> <span class="o">.</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="nf">meet</span> <span class="o">.</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nf">you</span> <span class="o">.</span> <span class="mi">8</span><span class="p">))</span>
<span class="o">'</span><span class="p">((</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nf">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="nf">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">))</span>
</pre></div>
</div>
<p>函数<code>assq</code>，<code>assv</code>，和<code>assoc</code>从关联表中搜寻一个项。这些函数从开始一步步搜索关联表。如果它们找到序对的car等于给定的key，就返回该序对。如果找不到函数返回#f。这些函数分别使用eq?，eqv?，和equal?比较键，这意味着assq最快，assoc最慢。这表示作为键的话，字符串，向量和表应该转化为符号或者数字（如果可能的话）以提高性能。</p>

<p>一般来说，<a href="http://www.shido.info/lisp/scheme_ah_e.html#hash">哈希表</a>在大量数据中搜索表现得更好一些。</p>

<p>下面展示在关联表中进行搜索的例子。</p>

<div class="codeblock"><div class="highlight type-scheme"><pre><span class="p">(</span><span class="k">define</span> <span class="nv">wc</span> <span class="o">'</span><span class="p">((</span><span class="nf">hi</span> <span class="o">.</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nf">everybody</span> <span class="o">.</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="nf">nice</span> <span class="o">.</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nf">to</span> <span class="o">.</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="nf">meet</span> <span class="o">.</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nf">you</span> <span class="o">.</span> <span class="mi">8</span><span class="p">)))</span>
<span class="err">⇒</span> <span class="nv">wc</span>

<span class="p">(</span><span class="nb">assq</span> <span class="ss">'hi</span> <span class="nv">wc</span><span class="p">)</span>
<span class="err">⇒</span>  <span class="p">(</span><span class="nf">hi</span> <span class="o">.</span> <span class="mi">3</span><span class="p">)</span>

<span class="p">(</span><span class="nb">assq</span> <span class="ss">'you</span> <span class="nv">wc</span><span class="p">)</span>
<span class="err">⇒</span>  <span class="p">(</span><span class="nf">you</span> <span class="o">.</span> <span class="mi">8</span><span class="p">)</span>

<span class="p">(</span><span class="nb">assq</span> <span class="ss">'i</span> <span class="nv">wc</span><span class="p">)</span>
<span class="err">⇒</span>  <span class="p">()</span>


<span class="p">(</span><span class="k">define</span> <span class="nv">n</span> <span class="o">'</span><span class="p">((</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nf">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="nf">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)))</span>
<span class="err">⇒</span>  <span class="nv">n</span>

<span class="p">(</span><span class="nb">assv</span> <span class="mi">1</span> <span class="nv">n</span><span class="p">)</span>
<span class="err">⇒</span>  <span class="p">(</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>

<span class="p">(</span><span class="nb">assv</span> <span class="mi">8</span> <span class="nv">n</span><span class="p">)</span>
<span class="err">⇒</span>  <span class="p">()</span>
</pre></div>
</div>
<h2 id='section-13-3'><span>13.3</span> 哈希表</h2>


<p><a href="http://en.wikipedia.org/wiki/Hash-table">哈希表</a>是一种数据类型，它使用哈希函数将键转化为整数，并将值存储在由该整数所指示的位置。当表足够稀疏时，搜索，插入，更新都能以O(1)完成。下面展示了MIT-Scheme里哈希表的一些基本函数。查询<a href="http://www.swiss.ai.mit.edu/projects/scheme/documentation/scheme_12.html#SEC119">MIT-Scheme Manul</a>获取更详细的信息。</p>

<p>
  <strong>(make-eq-hash-table size),</strong>
</p>

<p>
  <strong>(make-eqv-hash-table size),</strong>
</p>

<p>
  <strong>(make-equal-hash-table size),</strong>
</p>

<p>
  <strong>(make-string-hash-table size)</strong>
</p>

<p>这些函数创建哈希表。这些函数分别使用eq?，eqv?，equal?，和string=?比较键的值。哈希表的初始大小（<code>size</code>）可以选择性指定（optional）。由于只比较键的地址，所以eq-hash-table是最快的。由于键是序列，所以equal-hash-table和string-hash-table比较慢。</p>

<p>
  <strong>(hash-table/put! hash-table key datum)</strong>
</p>

<p>将<code>hash-table</code>中<code>key</code>对应的值设为<code>datum</code>。</p>

<p>
  <strong>(hash-table/get hash-table key default)</strong>
</p>

<p>返回<code>hash-table</code>中的<code>key</code>对应的值。如果<code>key</code>不存在于<code>hash-table</code>中，返回<code>default</code>。</p>

<p>
  <strong>(hash-table-&gt;alist hash-table)</strong>
</p>

<p>将<code>hash-table</code>转换为关联表。</p>

<h2 id='section-13-4'><span>13.4</span> 生成密码</h2>


<p>让我们写一个密码创建程序作为关联表和哈希表的例子。</p>

<p>从字典里得到的密码很容易被破解，但另一方面，完全随机的密码又很难记忆和输入。程序使用无规则的拼写创建10个密码。密码应该尽可能频繁更改，但是我懒于自己创建密码。使用这个程序，我可以简单地改变密码。</p>

<p>程序由两部分构成。一部分用于创建连续字符出现频率的数据（stat-spell.scm），另一个用于基于这个数据创建密码（make-pw.scm）。</p>

<h3 id='section-13-4-1'><span>13.4.1</span> stat-spell.scm</h3>


<p>这个程序可以阅读英语句子，数据存在哈希表里，并转换为关联表输出到一个文件（stat-spell.data）。[代码1]显示了源代码。</p>

<p>[代码1]</p>

<div class="codeblock"><div class="highlight type-scheme"><pre><span class="mi">01</span><span class="nv">:</span>     <span class="c1">;;; make an alist of probable spelling from a given English text</span>
<span class="mi">02</span><span class="nv">:</span>     
<span class="mi">03</span><span class="nv">:</span>     <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">skip-char?</span> <span class="nv">c</span><span class="p">)</span>
<span class="mi">04</span><span class="nv">:</span>       <span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nf">char-graphic?</span> <span class="nv">c</span><span class="p">))</span> <span class="p">(</span><span class="nb">memv</span> <span class="nv">c</span> <span class="o">'</span><span class="p">(</span><span class="o">#</span><span class="err">\</span><span class="nv">:</span> <span class="o">#</span><span class="err">\</span><span class="c1">; #\' #\" #\`))))</span>
<span class="mi">05</span><span class="nv">:</span>     
<span class="mi">06</span><span class="nv">:</span>     <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">ss-make-alist</span> <span class="nv">c</span> <span class="nv">alist</span><span class="p">)</span>
<span class="mi">07</span><span class="nv">:</span>       <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">p</span> <span class="p">(</span><span class="nb">assv</span> <span class="nv">c</span> <span class="nv">alist</span><span class="p">)))</span>
<span class="mi">08</span><span class="nv">:</span>         <span class="p">(</span><span class="k">if</span> <span class="nv">p</span>
<span class="mi">09</span><span class="nv">:</span>             <span class="p">(</span><span class="k">begin</span>
<span class="mi">10</span><span class="nv">:</span>              <span class="p">(</span><span class="nb">set-cdr!</span> <span class="nv">p</span> <span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">p</span><span class="p">)))</span>
<span class="mi">11</span><span class="nv">:</span>              <span class="nv">alist</span><span class="p">)</span>
<span class="mi">12</span><span class="nv">:</span>           <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">c</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">alist</span><span class="p">))))</span>
<span class="mi">13</span><span class="nv">:</span>     
<span class="mi">14</span><span class="nv">:</span>     <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">ss-make-dat</span> <span class="nv">filename</span><span class="p">)</span>
<span class="mi">15</span><span class="nv">:</span>       <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">char-hash</span> <span class="p">(</span><span class="nf">make-eqv-hash-table</span><span class="p">)))</span>
<span class="mi">16</span><span class="nv">:</span>         <span class="p">(</span><span class="nb">with-input-from-file</span> <span class="nv">filename</span>
<span class="mi">17</span><span class="nv">:</span>           <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span>
<span class="mi">18</span><span class="nv">:</span>     	<span class="p">(</span><span class="k">let</span> <span class="nv">loop</span> <span class="p">((</span><span class="nf">c</span> <span class="sc">#\Space</span><span class="p">))</span>
<span class="mi">19</span><span class="nv">:</span>     	  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">c1</span> <span class="p">(</span><span class="nb">read-char</span><span class="p">)))</span>
<span class="mi">20</span><span class="nv">:</span>                      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">eof-object?</span> <span class="nv">c1</span><span class="p">))</span>
<span class="mi">21</span><span class="nv">:</span>                          <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">skip-char?</span> <span class="nv">c1</span><span class="p">)</span>
<span class="mi">22</span><span class="nv">:</span>                              <span class="p">(</span><span class="nf">loop</span> <span class="nv">c</span><span class="p">)</span>
<span class="mi">23</span><span class="nv">:</span>                              <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">c1</span> <span class="p">(</span><span class="nb">char-downcase</span> <span class="nv">c1</span><span class="p">)))</span>
<span class="mi">24</span><span class="nv">:</span>     			   <span class="p">(</span><span class="nf">hash-table/put!</span> <span class="nv">char-hash</span> <span class="nv">c</span>
<span class="mi">25</span><span class="nv">:</span>     					    <span class="p">(</span><span class="nf">ss-make-alist</span> <span class="nv">c1</span> <span class="p">(</span><span class="nf">hash-table/get</span> <span class="nv">char-hash</span> <span class="nv">c</span> <span class="o">'</span><span class="p">())))</span>
<span class="mi">26</span><span class="nv">:</span>     			   <span class="p">(</span><span class="nf">loop</span> <span class="nv">c1</span><span class="p">))))))))</span>
<span class="mi">27</span><span class="nv">:</span>         <span class="p">(</span><span class="nb">with-output-to-file</span> <span class="s">"stat-spell.dat"</span>
<span class="mi">28</span><span class="nv">:</span>           <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span>
<span class="mi">29</span><span class="nv">:</span>     	<span class="p">(</span><span class="nb">display</span> <span class="s">"(define *stat-spell* \'("</span><span class="p">)</span>
<span class="mi">30</span><span class="nv">:</span>     	<span class="p">(</span><span class="nb">newline</span><span class="p">)</span>
<span class="mi">31</span><span class="nv">:</span>     	<span class="p">(</span><span class="k">let</span> <span class="nv">loop</span> <span class="p">((</span><span class="nf">alst</span> <span class="p">(</span><span class="nf">sort</span> <span class="p">(</span><span class="nf">hash-table-&gt;alist</span> <span class="nv">char-hash</span><span class="p">)</span> 
<span class="mi">32</span><span class="nv">:</span>     			       <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nf">char33:</span>     	  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">pair?</span> <span class="nv">alst</span><span class="p">)</span>
<span class="mi">34</span><span class="nv">:</span>     	      <span class="p">(</span><span class="k">begin</span>
<span class="mi">35</span><span class="nv">:</span>     		<span class="p">(</span><span class="nb">write</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">alst</span><span class="p">))</span>
<span class="mi">36</span><span class="nv">:</span>     		<span class="p">(</span><span class="nb">newline</span><span class="p">)</span>
<span class="mi">37</span><span class="nv">:</span>     		<span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">alst</span><span class="p">)))))</span>
<span class="mi">38</span><span class="nv">:</span>             <span class="p">(</span><span class="nb">display</span> <span class="s">"))"</span><span class="p">)</span>
<span class="mi">39</span><span class="nv">:</span>             <span class="p">(</span><span class="nb">newline</span><span class="p">)))))</span>
</pre></div>
</div>
<p>
  <strong>(skip-char? c)</strong>
</p>

<p>如果<code>c</code>不是图像字符或者<code>c</code>是 #:, #\;, #', or #"，就返回#t。读取文本时，这些字符会被跳过。</p>

<p>
  <strong>(ss-make-alist c alist)</strong>
</p>

<p>有两个参数；字符的频率的关联表（<code>alist</code>）和字符（<code>c</code>）。如果<code>c</code>在<code>alist</code>中，在序对的cdr部分增加一。如果不在，返回 (cons (cons c 1) alist)。这个函数使用了set-cdr!。</p>

<p>
  <strong>(ss-make-dat filename)</strong>
</p>

<p>从名为<code>filename</code>的文件中读取字符，并使用跟随字符的频率的关联表来关联这些读出的字符。结果以关联表形式存储在文件<a href="http://www.shido.info/lisp/stat-spell.dat">stat-spell.dat</a>。在34和35行，它在哈希表中更新了频率的关联表。存储在stat-spell.dat的最终数据是一个关联表的关联表。例如：</p>

<p>(#\v (#\y . 1) (#\a . 3) (#\o . 7) (#\e . 51) (#\i . 15))</p>

<p>表示 #\y, #\a, #\o, #\e, 和 #\i 跟随 #\v 之后出现的次数分别是1, 3, 7, 51, 和15次。</p>

<h3 id='section-13-4-2'><span>13.4.2</span> make-pw.scm</h3>


<p>基于 stat-spell.dat 创建十个密码。过程如下：</p>

<ol>
  <li>基于频率数据创建由9到13个随机字符组成字符串表。字符 #\Space 被添加在表结尾。</li>
  <li>添加一个00到99之间的随机数在随机选取的字符串表的结尾。</li>
  <li>随机地将 #\Space 转换为 #-, #_, #\/, #\Space, #., 或者 #\,。</li>
  <li>随机地将30%的字母字符变为大写。</li>
</ol>

<div class="codeblock"><div class="highlight type-scheme"><pre><span class="mi">01</span><span class="nv">:</span>     <span class="c1">;;; make password from the alist of probable spelling</span>
<span class="mi">02</span><span class="nv">:</span>     
<span class="mi">03</span><span class="nv">:</span>     <span class="p">(</span><span class="nb">load</span> <span class="s">"stat-spell.dat"</span><span class="p">)</span> <span class="c1">; *stat-spell* (alist for following characters) is in.</span>
<span class="mi">04</span><span class="nv">:</span>     
<span class="mi">05</span><span class="nv">:</span>     <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">alist-&gt;hash</span> <span class="nv">al</span> <span class="nv">mode</span><span class="p">)</span>
<span class="mi">06</span><span class="nv">:</span>       <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">h</span> <span class="p">(</span><span class="k">case</span> <span class="nv">mode</span>
<span class="mi">07</span><span class="nv">:</span>                  <span class="p">((</span><span class="nf">eq</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-eq-hash-table</span><span class="p">))</span>
<span class="mi">08</span><span class="nv">:</span>                  <span class="p">((</span><span class="nf">eqv</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-eqv-hash-table</span><span class="p">))</span>
<span class="mi">09</span><span class="nv">:</span>                  <span class="p">((</span><span class="nf">equal</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-equal-hash-table</span><span class="p">))</span>
<span class="mi">10</span><span class="nv">:</span>                  <span class="p">((</span><span class="nb">string</span><span class="p">)</span> <span class="p">(</span><span class="nf">make-string-hash-table</span><span class="p">)))))</span>
<span class="mi">11</span><span class="nv">:</span>         <span class="p">(</span><span class="nb">for-each</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">p</span><span class="p">)</span>
<span class="mi">12</span><span class="nv">:</span>                     <span class="p">(</span><span class="nf">hash-table/put!</span> <span class="nv">h</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">p</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">p</span><span class="p">)))</span>
<span class="mi">13</span><span class="nv">:</span>                   <span class="nv">al</span><span class="p">)</span>
<span class="mi">14</span><span class="nv">:</span>         <span class="nv">h</span><span class="p">))</span>
<span class="mi">15</span><span class="nv">:</span>     
<span class="mi">16</span><span class="nv">:</span>     <span class="p">(</span><span class="k">define</span> <span class="nv">*stat-spell-hash*</span> <span class="p">(</span><span class="nf">alist-&gt;hash</span> <span class="nv">*stat-spell*</span> <span class="ss">'eqv</span><span class="p">))</span>
<span class="mi">17</span><span class="nv">:</span>     
<span class="mi">18</span><span class="nv">:</span>     <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">pw-random-select</span> <span class="nv">vec</span><span class="p">)</span>
<span class="mi">19</span><span class="nv">:</span>       <span class="p">(</span><span class="nb">vector-ref</span> <span class="nv">vec</span> <span class="p">(</span><span class="nf">random</span> <span class="p">(</span><span class="nb">vector-length</span> <span class="nv">vec</span><span class="p">))))</span>
<span class="mi">20</span><span class="nv">:</span>     
<span class="mi">21</span><span class="nv">:</span>     <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">random00</span><span class="p">)</span>
<span class="mi">22</span><span class="nv">:</span>       <span class="p">(</span><span class="k">let</span> <span class="nv">loop</span> <span class="p">((</span><span class="nf">i</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">acc</span> <span class="o">'</span><span class="p">()))</span>
<span class="mi">23</span><span class="nv">:</span>         <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">i</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">24</span><span class="nv">:</span>             <span class="p">(</span><span class="nb">list-&gt;string</span> <span class="nv">acc</span><span class="p">)</span>
<span class="mi">25</span><span class="nv">:</span>           <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">i</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nf">pw-random-select</span> <span class="o">'#</span><span class="p">(</span><span class="sc">#\0</span> <span class="sc">#\1</span> <span class="sc">#\2</span> <span class="sc">#\3</span> <span class="sc">#\4</span> <span class="sc">#\5</span> <span class="sc">#\6</span> <span class="sc">#\7</span> <span class="sc">#\8</span> <span class="sc">#\9</span><span class="p">))</span> <span class="nv">acc</span><span class="p">)))))</span>
<span class="mi">26</span><span class="nv">:</span>     
<span class="mi">27</span><span class="nv">:</span>     <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">occasional-upcase</span> <span class="nv">c</span><span class="p">)</span>
<span class="mi">28</span><span class="nv">:</span>       <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="p">(</span><span class="nf">random</span> <span class="mi">10</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">29</span><span class="nv">:</span>           <span class="p">(</span><span class="nb">char-upcase</span> <span class="nv">c</span><span class="p">)</span>
<span class="mi">30</span><span class="nv">:</span>         <span class="nv">c</span><span class="p">))</span>
<span class="mi">31</span><span class="nv">:</span>     
<span class="mi">32</span><span class="nv">:</span>     <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">pw-enhance</span> <span class="nv">ls</span><span class="p">)</span>
<span class="mi">33</span><span class="nv">:</span>       <span class="p">(</span><span class="nb">list-&gt;string</span>
<span class="mi">34</span><span class="nv">:</span>        <span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">c</span><span class="p">)</span>
<span class="mi">35</span><span class="nv">:</span>               <span class="p">(</span><span class="k">cond</span>
<span class="mi">36</span><span class="nv">:</span>                <span class="p">((</span><span class="nb">char=?</span> <span class="nv">c</span> <span class="sc">#\Space</span><span class="p">)</span>
<span class="mi">37</span><span class="nv">:</span>                 <span class="p">(</span><span class="nf">pw-random-select</span>  <span class="o">'#</span><span class="p">(</span><span class="sc">#\-</span> <span class="sc">#\_</span> <span class="sc">#\/</span>  <span class="sc">#\Space</span>  <span class="sc">#\.</span> <span class="o">#</span><span class="err">\</span><span class="o">,</span> <span class="o">#</span><span class="err">\</span><span class="nv">@</span> <span class="sc">#\?</span> <span class="sc">#\(</span> <span class="sc">#\)</span><span class="p">)))</span>
<span class="mi">38</span><span class="nv">:</span>                <span class="p">((</span><span class="nb">char-alphabetic?</span> <span class="nv">c</span><span class="p">)</span>
<span class="mi">39</span><span class="nv">:</span>                 <span class="p">(</span><span class="nf">occasional-upcase</span> <span class="nv">c</span><span class="p">))</span>
<span class="mi">40</span><span class="nv">:</span>                <span class="p">(</span><span class="k">else</span> <span class="nv">c</span><span class="p">)))</span>
<span class="mi">41</span><span class="nv">:</span>             <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nf">reverse!</span> <span class="nv">ls</span><span class="p">)))))</span>
<span class="mi">42</span><span class="nv">:</span>         
<span class="mi">43</span><span class="nv">:</span>     
<span class="mi">44</span><span class="nv">:</span>     <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">random-following</span> <span class="nv">alist</span><span class="p">)</span>
<span class="mi">45</span><span class="nv">:</span>       <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">n</span> <span class="p">(</span><span class="nf">random</span> <span class="p">(</span><span class="nb">apply</span> <span class="nv">+</span> <span class="p">(</span><span class="nb">map</span> <span class="nv">cdr</span> <span class="nv">alist</span><span class="p">)))))</span>
<span class="mi">46</span><span class="nv">:</span>         <span class="p">(</span><span class="k">let</span> <span class="nv">loop</span> <span class="p">((</span><span class="nf">j</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">alist</span> <span class="nv">alist</span><span class="p">))</span>
<span class="mi">47</span><span class="nv">:</span>           <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">pair?</span> <span class="nv">alist</span><span class="p">)</span>
<span class="mi">48</span><span class="nv">:</span>     	  <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nf">pair</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">alist</span><span class="p">))</span>
<span class="mi">49</span><span class="nv">:</span>     		 <span class="p">(</span><span class="nf">k</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">j</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">pair</span><span class="p">))))</span>
<span class="mi">50</span><span class="nv">:</span>     	    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">k</span> <span class="nv">n</span><span class="p">)</span>
<span class="mi">51</span><span class="nv">:</span>     		<span class="p">(</span><span class="nb">car</span> <span class="nv">pair</span><span class="p">)</span>
<span class="mi">52</span><span class="nv">:</span>     		<span class="p">(</span><span class="nf">loop</span> <span class="nv">k</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">alist</span><span class="p">))))))))</span>
<span class="mi">53</span><span class="nv">:</span>     
<span class="mi">54</span><span class="nv">:</span>     <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">make-pw</span> <span class="nv">h</span> <span class="nv">n</span><span class="p">)</span>
<span class="mi">55</span><span class="nv">:</span>       <span class="p">(</span><span class="k">let</span> <span class="nv">loop</span> <span class="p">((</span><span class="nf">i</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">c</span> <span class="sc">#\Space</span><span class="p">)</span> <span class="p">(</span><span class="nf">acc</span> <span class="o">'</span><span class="p">()))</span>
<span class="mi">56</span><span class="nv">:</span>         <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">i</span> <span class="nv">n</span><span class="p">)</span>
<span class="mi">57</span><span class="nv">:</span>             <span class="p">(</span><span class="nb">string-append</span>
<span class="mi">58</span><span class="nv">:</span>              <span class="p">(</span><span class="nf">pw-enhance</span> <span class="p">(</span><span class="nb">cons</span> <span class="sc">#\Space</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">c</span> <span class="nv">acc</span><span class="p">)))</span>
<span class="mi">59</span><span class="nv">:</span>              <span class="p">(</span><span class="nf">random00</span><span class="p">))</span>
<span class="mi">60</span><span class="nv">:</span>           <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">i</span><span class="p">)</span>
<span class="mi">61</span><span class="nv">:</span>             <span class="p">(</span><span class="nf">random-following</span> <span class="p">(</span><span class="nf">hash-table/get</span> <span class="nv">h</span> <span class="nv">c</span> <span class="o">'</span><span class="p">((</span><span class="sc">#\Space</span> <span class="o">.</span> <span class="mi">1</span><span class="p">))))</span>
<span class="mi">62</span><span class="nv">:</span>             <span class="p">(</span><span class="nb">cons</span> <span class="nv">c</span> <span class="nv">acc</span><span class="p">)))))</span>
<span class="mi">63</span><span class="nv">:</span>         
<span class="mi">64</span><span class="nv">:</span>     <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">pw-candidates</span><span class="p">)</span>
<span class="mi">65</span><span class="nv">:</span>       <span class="p">(</span><span class="k">let</span> <span class="nv">loop</span> <span class="p">((</span><span class="nf">i</span> <span class="mi">0</span><span class="p">))</span>
<span class="mi">66</span><span class="nv">:</span>         <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">i</span> <span class="mi">10</span><span class="p">)</span>
<span class="mi">67</span><span class="nv">:</span>             <span class="p">(</span><span class="k">begin</span>
<span class="mi">68</span><span class="nv">:</span>              <span class="p">(</span><span class="nb">display</span> <span class="nv">i</span><span class="p">)</span>
<span class="mi">69</span><span class="nv">:</span>              <span class="p">(</span><span class="nb">display</span> <span class="s">": "</span><span class="p">)</span>
<span class="mi">70</span><span class="nv">:</span>              <span class="p">(</span><span class="nb">write</span> <span class="p">(</span><span class="nf">make-pw</span> <span class="nv">*stat-spell-hash*</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">9</span> <span class="p">(</span><span class="nf">random</span> <span class="mi">4</span><span class="p">))))</span>
<span class="mi">71</span><span class="nv">:</span>              <span class="p">(</span><span class="nb">newline</span><span class="p">)</span>
<span class="mi">72</span><span class="nv">:</span>              <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">i</span><span class="p">)))</span>
<span class="mi">73</span><span class="nv">:</span>           <span class="ss">'done</span><span class="p">)))</span>
</pre></div>
</div>
<h2 id='section-13-5'><span>13.5</span> 总结</h2>


<p>你可以在<a href="http://www.shido.info/lisp/scheme_ah.zip">这儿</a>下载密码生成程序。</p>

<p>我将在下一章讲解向量。</p>

  	</div>
</div>

		
			
			<div class="navigation">
				
					<a class="prev_page" href="./chapter12.html">&laquo; 第 12 章符号</a>
				
				
					<a class="next_page" href="./chapter14.html">第 14 章向量和结构体 &raquo;</a>
				
			</div>
			
	</div>	
	</div>
</body>
</html>
