<!DOCTYPE html>
<html lang="zh_CN">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<title>第 7 章 重复</title>
<meta name="author" content="DeathKing">
<link rel="stylesheet" href="style.css">
</head>
<body><div class="entry"><div class="container">
		
<div class="item chapter">
	<h1 id="chapter-7">
<span>第 7 章</span> 重复</h1>
	<ol class="toc">
<li class="level-2">
            <a href="#section-7-1">7.1 简介</a>
          </li>
          <li class="level-2">
            <a href="#section-7-2">7.2 递归</a>
          </li>
          <li class="level-2">
            <a href="#section-7-3">7.3 尾递归</a>
          </li>
          <li class="level-2">
            <a href="#section-7-4">7.4 命名let</a>
          </li>
</ol>
<div class="main">
  		<h2 id="section-7-1">
<span>7.1</span> 简介</h2>


<p>本章中我会介绍重复。通过重复，你可以编写“通常的”程序。虽然也可以使用<code>do</code>表达式，但Scheme中通常通过递归实现重复。</p>

<h2 id="section-7-2">
<span>7.2</span> 递归</h2>


<p>在自己的定义中调用自己的函数叫做<strong>递归函数（Recursive Function）</strong>。虽然这听起来很奇怪，但是循环的常见方法。If you have an analogy comparing functions to machines, recursion makes no sense. 然而，正因为函数式过程，函数调用自己是有意义的。比如说，让我们来考察一下文献调研吧。你可能需要去阅读你正在阅读的文献所引用的文献（cited-1）。进一步，你可能还需要去阅读文件（cite-1）所引用的其它文献。这样，文献调研就是一个递归的过程，你也可以重复这个调研过程直到满足了特定条件（比如说，你累了）。Thus, an analogy that compares functions in programming languages to some kind of human activities (say, literature survey) is useful to understand recursive functions.</p>

<p>我们通常使用计算阶乘来解释递归。</p>

<div class="codeblock">
<div class="highlight type-scheme"><pre><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">fact</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span>
      <span class="mi">1</span>
      <span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">fact</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))))</span>
</pre></div>
</div>
<p><code>(fact 5)</code>的计算过程如下：</p>

<div class="codeblock">
<div class="highlight type-text"><pre>(fact 5)
⇒ 5 * (fact 4)
⇒ 5 * 4 * (fact 3)
⇒ 5 * 4 * 3 * (fact 2)
⇒ 5 * 4 * 3 * 2 * (fact 1)
⇒ 5 * 4 * 3 * 2 * 1
⇒ 5 * 4 * 3 * 2
⇒ 5 * 4 * 6
⇒ 5 * 24
⇒ 120
</pre></div>
</div>
<p><code>(fact 5)</code>调用<code>(fact 4)</code>，<code>(fact 4)</code>调用<code>(fact 3)</code>，最后<code>(fact 1)</code>被调用。<code>(fact 5)</code>，<code>(fact 4)</code>……以及<code>(fact 1)</code>都被分配了不同的存储空间，直到<code>(fact (- i 1))</code>返回一个值之前，<code>(fact i)</code>都会保留在内存中，由于存在函数调用的开销，这通常会占用更多地内存空间和计算时间。</p>

<p>然而，递归函数可以以一种简单的方式表达重复。表是被递归定义的，进而表和递归函数可以很好地配合。例如，一个让表中所有元素翻倍的函数可以像下面这样写。如果参数是空表，那么函数应该停止计算并返回一个空表。</p>

<div class="codeblock">
<div class="highlight type-scheme"><pre><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">list*2</span> <span class="nv">ls</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">ls</span><span class="p">)</span>
      <span class="o">'</span><span class="p">()</span>
      <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="p">(</span><span class="nb">car </span><span class="nv">ls</span><span class="p">))</span>
	         <span class="p">(</span><span class="nf">list*2</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">ls</span><span class="p">)))))</span>
</pre></div>
</div>
<blockquote>
  <p>练习1</p>

  <p>用递归编写下面的函数。</p>

  <ol>
<li>用于统计表中元素个数的<code>my-length</code>函数。（<code>length</code>是一个预定义函数）。</li>
    <li>一个求和表中元素的函数。</li>
    <li>一个分别接受一个表<code>ls</code>和一个对象<code>x</code>的函数，该函数返回从<code>ls</code>中删除<code>x</code>后得到的表。</li>
    <li>一个分别接受一个表<code>ls</code>和一个对象<code>x</code>的函数，该函数返回<code>x</code>在<code>ls</code>中首次出现的位置。索引从<code>0</code>开始。如果<code>x</code>不在<code>ls</code>中，函数返回<code>#f</code>。</li>
  </ol>
</blockquote>

<h2 id="section-7-3">
<span>7.3</span> 尾递归</h2>


<p>普通的递归调用并不高效因为它既浪费存储空间又具有函数调用开销。与之相反，尾递归函数包含了计算结果，当计算结束时直接将其返回。特别地，由于Scheme规范要求尾递归调用转化为循环，因此尾递归调用就不存在函数调用开销。</p>

<p>[代码片段2]展示了[代码片段1]中函数<code>fact</code>的尾递归版本。</p>

<div class="codeblock">
<div class="highlight type-scheme"><pre><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">fact-tail</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">fact-rec</span> <span class="nv">n</span> <span class="nv">n</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">fact-rec</span> <span class="nv">n</span> <span class="nv">p</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span>
      <span class="nv">p</span>
      <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">m</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))</span>
	<span class="p">(</span><span class="nf">fact-rec</span> <span class="nv">m</span> <span class="p">(</span><span class="nb">* </span><span class="nv">p</span> <span class="nv">m</span><span class="p">)))))</span>
</pre></div>
</div>
<p><code>fact-tail</code>计算阶乘的过程像这样：</p>

<div class="codeblock">
<div class="highlight type-text"><pre>(fact-tail 5)
⇒ (fact-rec 5 5)
⇒ (fact-rec 4 20)
⇒ (fact-rec 3 60)
⇒ (fact-rec 2 120)
⇒ (fact-rec 1 120)
⇒ 120
</pre></div>
</div>
<p>因为<code>fact-rec</code>并不等待其它函数的计算结果，因此当它计算结束时即从内存中释放。计算通过修改<code>fact-rec</code>的参数来演进，这基本上等同于循环。如上文所述，Scheme将尾递归转化为循环，Scheme就无需提供循环的语法来实现重复。</p>

<blockquote>
  <p>练习2</p>

  <p>用尾递归编写下面的函数</p>

  <ol>
<li>用于翻转表元素顺序的<code>my-reverse</code>函数。（<code>reverse</code>函数是预定义函数）</li>
    <li>求和由数构成的表。</li>
    <li>将一个代表正整数的字符串转化为对应整数。例如，”1232”会被转化为1232。不需要检查不合法的输入。提示，字符到整数的转化是通过将字符#\0……#\9的ASCII减去48，可以使用函数<code>char-&gt;integer</code>来获得字符的ASCII码。函数<code>string-&gt;list</code>可以将字符串转化为由字符构成的表。</li>
  </ol>
</blockquote>

<h2 id="section-7-4">
<span>7.4</span> 命名let</h2>


<p>命名<code>let</code>（<strong>named let</strong>）可以用来表达循环。[代码片段3]中的函数<code>fact-let</code>展示了如何使用命名<code>let</code>来计算阶乘。</p>
  	</div>
</div>

		
			
			<div class="navigation">
				
					<a class="prev_page" href="/yast-cn/chapter6.html">« 第 6 章局部变量</a>
				
				
					<a class="next_page" href="/yast-cn/chapter8.html">第 8 章高阶函数 »</a>
				
			</div>
			
		
	</div></div></body>
</html>
