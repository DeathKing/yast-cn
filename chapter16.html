<!doctype html>
<html lang="zh_CN">
<head>
	<meta charset="utf-8" />
	<title>第 16 章 继续</title>
    <meta name="author" content="DeathKing" />
    <link rel="stylesheet" href="style.css" />
</head>

<body>
	<div class="entry">
    <div class="container">
		
<div class="item chapter">
	<h1 id="chapter-16"><span>第 16 章</span> 继续</h1>
	<ol class="toc">          <li class="level-2">
            <a href="#section-16-1">16.1 简介</a>
          </li>
          <li class="level-2">
            <a href="#section-16-2">16.2 广义继续</a>
          </li>
          <li class="level-2">
            <a href="#section-16-3">16.3 Continuation-Passing-Style(CPS)</a>
          </li>
          <li class="level-3">
            <a href="#section-16-3-1">16.3.1 简单的CPS</a>
          </li>
          <li class="level-3">
            <a href="#section-16-3-2">16.3.2 以CPS编写递归函数</a>
          </li>
          <li class="level-2">
            <a href="#section-16-4">16.4 Scheme中的继续</a>
          </li>
          <li class="level-3">
            <a href="#section-16-4-1">16.4.1 使用`call/cc`抛出值</a>
          </li>
          <li class="level-3">
            <a href="#section-16-4-2">16.4.2 生成器</a>
          </li>
          <li class="level-3">
            <a href="#section-16-4-3">16.4.3 协程</a>
          </li>
          <li class="level-2">
            <a href="#section-16-5">16.5 总结</a>
          </li>
</ol>
  	<div class="main">
  		<h2 id='section-16-1'><span>16.1</span> 简介</h2>


<p>本章介绍的是Scheme中特有的数据类型——<strong>继续（Continuation）</strong>。由于其他程序设计语言并没有这种数据类型，因此它难于理解。当下，你并不需要彻底理解清楚，只需要大致了解。</p>

<p>我会讲解广义的继续和简短地介绍<strong>Continuation-Passing-Style(CPS)</strong>，然后再讲解Scheme中的继续。我认为通过这种方式理解继续会比较容易。</p>

<h2 id='section-16-2'><span>16.2</span> 广义继续</h2>


<p>继续是在返回到<strong>顶层（Toplevel）</strong>之前所需要执行的计算。实际上，继续存在于计算的每时每刻。以<code>(* 3 (+ 1 2))</code>为例，在求值完<code>(+ 1 2)</code>后，应该计算<code>{ (* 3 []) }</code>乘以3。然而，大多数语言都不显式地这么做，程序员对此并不熟悉。</p>

<h2>Continuation-Passing-Style(CPS)</h2>

<h3 id='section-16-3-1'><span>16.3.1</span> 简单的CPS</h3>


<p>CPS是一种编程风格，在这种风格中，把依赖于当前函数结果的后续函数作为参数传递给当前函数。<strong>代码片段1</strong>展示了以CPS编写的加法和乘法。在<code>k+</code>和<code>k*</code>中，<code>k</code>是后续函数。</p>

<div class="codeblock"><div class="highlight type-scheme"><pre><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">return</span> <span class="nv">x</span><span class="p">)</span>
  <span class="nv">x</span><span class="p">)</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">k+</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">k</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">k</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">k*</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">k</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">k</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>
</pre></div>
</div>
<p><strong>例1</strong>演示了如何使用CPS计算<code>(* 3 (+ 1 2))</code>。</p>

<div class="codeblock"><div class="highlight type-scheme"><pre><span class="p">(</span><span class="nf">k+</span> <span class="mi">1</span> <span class="mi">2</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">k*</span> <span class="nv">x</span> <span class="mi">3</span> <span class="nv">return</span><span class="p">)))</span>
</pre></div>
</div>
<p>Scheme的普通形式中，值在括号外被计算（#TBD In the ordinary form of Scheme, values that are calculated in parentheses go outside of them. ）与此相反，CPS中，值向其它括号内传递。在<strong>例1</strong>中，<code>k+</code>把<code>(+ 1 2)</code>的值传递给<code>(lambda (x) (k* x 3 return))</code>，而<code>k*</code>把<code>(* (+ 1 2) 3)</code>的结果传给<code>return</code>。</p>

<h3 id='section-16-3-2'><span>16.3.2</span> 以CPS编写递归函数</h3>


<p>递归函数同样可以以CPS编写。<strong>代码片段2</strong>展示了计算阶乘的函数如何用普通方式编写（<code>fact</code>）和以CPS编写(<code>kfact</code>)。</p>

<div class="codeblock"><div class="highlight type-scheme"><pre><span class="c1">;;; normal factorial</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">fact</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> 
      <span class="mi">1</span>
      <span class="p">(</span><span class="nb">*</span> <span class="nv">n</span> <span class="p">(</span><span class="nf">fact</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)))))</span>

<span class="c1">;;; CPS factorial</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">kfact</span> <span class="nv">n</span> <span class="nv">k</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> 
      <span class="p">(</span><span class="nf">k</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">kfact</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">k</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">n</span> <span class="nv">x</span><span class="p">))))))</span>
</pre></div>
</div>
<p><strong>例2</strong>将3与4的阶乘相加。</p>

<div class="codeblock"><div class="highlight type-scheme"><pre><span class="c1">;;; normal</span>
<span class="p">(</span><span class="nb">+</span> <span class="mi">3</span> <span class="p">(</span><span class="nf">fact</span> <span class="mi">4</span><span class="p">))</span>

<span class="c1">;;; CPS</span>
<span class="p">(</span><span class="nf">kfact</span> <span class="mi">4</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">k+</span> <span class="nv">x</span> <span class="mi">3</span> <span class="nv">return</span><span class="p">)))</span>
</pre></div>
</div>
<p><strong>代码片段3</strong>演示了如何分别用普通方式和CPS编写用于计算表中元素的积的函数。在CPS函数中，后继函数存储再局部变量<code>break</code>中，因此当元素乘以0时，可以立即退出。</p>

<div class="codeblock"><div class="highlight type-scheme"><pre><span class="c1">;;; normal</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">product</span> <span class="nv">ls</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="nv">loop</span> <span class="p">((</span><span class="nf">ls</span> <span class="nv">ls</span><span class="p">)</span> <span class="p">(</span><span class="nf">acc</span> <span class="mi">1</span><span class="p">))</span>
    <span class="p">(</span><span class="k">cond</span>
     <span class="p">((</span><span class="nb">null?</span> <span class="nv">ls</span><span class="p">)</span> <span class="nv">acc</span><span class="p">)</span>
     <span class="p">((</span><span class="nb">zero?</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">ls</span><span class="p">))</span> <span class="mi">0</span><span class="p">)</span>
     <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">ls</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">ls</span><span class="p">)</span> <span class="nv">acc</span><span class="p">))))))</span>

<span class="c1">;;; CPS</span>
<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">kproduct</span> <span class="nv">ls</span> <span class="nv">k</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">break</span> <span class="nv">k</span><span class="p">))</span>
    <span class="p">(</span><span class="k">let</span> <span class="nv">loop</span> <span class="p">((</span><span class="nf">ls</span> <span class="nv">ls</span><span class="p">)</span> <span class="p">(</span><span class="nf">k</span> <span class="nv">k</span><span class="p">))</span>
      <span class="p">(</span><span class="k">cond</span>
       <span class="p">((</span><span class="nb">null?</span> <span class="nv">ls</span><span class="p">)</span> <span class="p">(</span><span class="nf">k</span> <span class="mi">1</span><span class="p">))</span>
       <span class="p">((</span><span class="nb">zero?</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">ls</span><span class="p">))</span> <span class="p">(</span><span class="nf">break</span> <span class="mi">0</span><span class="p">))</span>
       <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">ls</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">k</span> <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">ls</span><span class="p">)</span> <span class="nv">x</span><span class="p">)))))))))</span>
</pre></div>
</div>
<p><strong>例3</strong>将100与<code>'(2 4 7)</code>的积相加。</p>

<div class="codeblock"><div class="highlight type-scheme"><pre><span class="c1">;;; normal</span>
<span class="p">(</span><span class="nb">+</span> <span class="mi">100</span> <span class="p">(</span><span class="nf">product</span> <span class="o">'</span><span class="p">(</span><span class="nf">2</span> <span class="mi">4</span> <span class="mi">7</span><span class="p">)))</span>

<span class="c1">;;; CPS</span>
<span class="p">(</span><span class="nf">kproduct</span> <span class="o">'</span><span class="p">(</span><span class="nf">2</span> <span class="mi">4</span> <span class="mi">7</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">k+</span> <span class="nv">x</span> <span class="mi">100</span> <span class="nv">return</span><span class="p">)))</span>
</pre></div>
</div>
<p>尽管CPS在这样简单的情况中并不实用，但在一些像是自然语言解析和逻辑编程等复杂程序中非常有用，因为与通常的编程风格相比，CPS可以更灵活地改变后续过程。</p>

<p><strong>异常处理（Exception handling）</strong>就是这种情况的简单例子。<strong>代码片段4</strong>演示了<code>kproduct</code>的错误处理版本，程序中当非数字值出现在输入表中，在其被打印时，计算就会终止。</p>

<div class="codeblock"><div class="highlight type-scheme"><pre><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">non-number-value-error</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display</span> <span class="s">"Value error: "</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display</span>  <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">display</span> <span class="s">" is not number."</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">newline</span><span class="p">)</span>
  <span class="ss">'error</span><span class="p">)</span>

<span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">kproduct</span> <span class="nv">ls</span> <span class="nv">k</span> <span class="nv">k-value-error</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">break</span> <span class="nv">k</span><span class="p">))</span>
    <span class="p">(</span><span class="k">let</span> <span class="nv">loop</span> <span class="p">((</span><span class="nf">ls</span> <span class="nv">ls</span><span class="p">)</span> <span class="p">(</span><span class="nf">k</span> <span class="nv">k</span><span class="p">))</span>
      <span class="p">(</span><span class="k">cond</span>
       <span class="p">((</span><span class="nb">null?</span> <span class="nv">ls</span><span class="p">)</span> <span class="p">(</span><span class="nf">k</span> <span class="mi">1</span><span class="p">))</span>
       <span class="p">((</span><span class="nb">not</span> <span class="p">(</span><span class="nb">number?</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">ls</span><span class="p">)))</span> <span class="p">(</span><span class="nf">k-value-error</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">ls</span><span class="p">)))</span>
       <span class="p">((</span><span class="nb">zero?</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">ls</span><span class="p">))</span> <span class="p">(</span><span class="nf">break</span> <span class="mi">0</span><span class="p">))</span>
       <span class="p">(</span><span class="k">else</span> <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">ls</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">k</span> <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">ls</span><span class="p">)</span> <span class="nv">x</span><span class="p">)))))))))</span>
</pre></div>
</div>
<div class="codeblock"><div class="highlight type-scheme"><pre><span class="c1">;;; valid</span>
<span class="p">(</span><span class="nf">kproduct</span> <span class="o">'</span><span class="p">(</span><span class="nf">2</span> <span class="mi">4</span> <span class="mi">7</span><span class="p">)</span> 
	  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">k+</span> <span class="nv">x</span> <span class="mi">100</span> <span class="nv">return</span><span class="p">))</span> 
	  <span class="nv">non-number-value-error</span><span class="p">)</span>
<span class="c1">;Value: 156</span>

<span class="c1">;;; invalid</span>
<span class="p">(</span><span class="nf">kproduct</span> <span class="o">'</span><span class="p">(</span><span class="nf">2</span> <span class="mi">4</span> <span class="mi">7</span> <span class="nv">hoge</span><span class="p">)</span> 
	  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">k+</span> <span class="nv">x</span> <span class="mi">100</span> <span class="nv">return</span><span class="p">))</span> 
	  <span class="nv">non-number-value-error</span><span class="p">)</span>
<span class="nv">Value</span> <span class="nv">error:</span> <span class="nv">hoge</span> <span class="nv">is</span> <span class="nv">not</span> <span class="nv">number</span><span class="o">.</span>
<span class="c1">;Value: error</span>
</pre></div>
</div>
<h2 id='section-16-4'><span>16.4</span> Scheme中的继续</h2>


<p>通过上面的讲解，你应该掌握了继续。继续有下面的性质：</p>

<ol>
  <li>存在于整个计算过程中；</li>
  <li>函数式程序设计语言和CPS可以显式地处理它；</li>
</ol>

<p>另外，上面的例子展示的是<strong>闭包链（Chain of closure）</strong>。然而，阅读和编写CPS程序是痛苦的，以通常的方式来处理继续会更方便一点。因此，Scheme中将继续实现为<strong>一级对象（first class object）</strong>（这意味这Scheme中的继续是个普通数据类型），任何时候都可以通过<code>call-with-current-continuation</code>来调用。由于继续是普通数据类型，你可以随心所欲地重用。考虑到<code>call-with-current-continuation</code>名字过长，通常使用其缩略名<code>call/cc</code>。</p>

<div class="codeblock"><div class="highlight type-scheme"><pre><span class="p">(</span><span class="k">define</span> <span class="nv">call/cc</span> <span class="nv">call-with-current-continuation</span><span class="p">)</span>
</pre></div>
</div>
<p>函数<code>call-with-current-continuation (call/cc)</code>接受一个参数。该参数是一个函数，函数的参数接收当前的继续。</p>

<p>下面是例子：</p>

<div class="codeblock"><div class="highlight type-scheme"><pre><span class="p">(</span><span class="nb">*</span> <span class="mi">3</span> <span class="p">(</span><span class="nb">call/cc</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">k</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))))</span>     <span class="c1">;⇒ 9      ; [1]</span>
<span class="p">(</span><span class="nb">*</span> <span class="mi">3</span> <span class="p">(</span><span class="nb">call/cc</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">k</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">k</span> <span class="mi">2</span><span class="p">)))))</span> <span class="c1">;⇒ 6      ; [2]</span>
</pre></div>
</div>
<p>在<strong>情况[1]</strong>中，继续并没有被调用，语句的行为与普通S-表达式相同。另一方面，在<strong>情况[2]</strong>中，继续以2作为参数被调用。在这种情况中，继续的参数跳过了<code>call/cc</code>的处理，并逃逸至<code>call/cc</code>的外部。这种情况中，<code>k</code>是一个一元函数，等价于<code>(lambda (x) (* 3 x))</code>。</p>

<p>大体来说，当前继续存储了从<code>call/cc</code>调用点到顶层的处理过程。当前继续可以像其它数据类型那样存储起来，并随心所欲地重用。</p>

<div class="codeblock"><div class="highlight type-scheme"><pre><span class="p">(</span><span class="k">define</span> <span class="nv">cc</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">*</span> <span class="mi">3</span> <span class="p">(</span><span class="nb">call/cc</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">k</span><span class="p">)</span>
                  <span class="p">(</span><span class="k">set!</span> <span class="nv">cc</span> <span class="nv">k</span><span class="p">)</span>
                  <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))))</span>
</pre></div>
</div>
<p>由于当前继续是回到顶层的处理过程，它的返回会忽略周围的S-表达式。</p>

<div class="codeblock"><div class="highlight type-scheme"><pre><span class="p">(</span><span class="nb">+</span> <span class="mi">100</span> <span class="p">(</span><span class="nf">cc</span> <span class="mi">3</span><span class="p">))</span>  <span class="c1">;⇒ 9 </span>
<span class="p">(</span><span class="nb">+</span> <span class="mi">100</span> <span class="p">(</span><span class="nf">cc</span> <span class="mi">10</span><span class="p">))</span> <span class="c1">;⇒ 30</span>
</pre></div>
</div>
<h3>使用<code>call/cc</code>抛出值</h3>

<p>从一个计算过程中逃逸出来，是使用当前继续的最容易的方法。<strong>代码片段5</strong>演示了搜索树（嵌套表）的函数。如果函数在树中找到<code>obj</code>，那么它返回该对象，否则返回<code>#f</code>。一旦找到<code>obj</code>，函数直接将其抛出至最外部。</p>

<div class="codeblock"><div class="highlight type-scheme"><pre><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">find-leaf</span> <span class="nv">obj</span> <span class="nv">tree</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">call/cc</span>
    <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">cc</span><span class="p">)</span>
       <span class="p">(</span><span class="k">letrec</span> <span class="p">((</span><span class="nf">iter</span>
	               <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">tree</span><span class="p">)</span>
		              <span class="p">(</span><span class="k">cond</span>
		                <span class="p">((</span><span class="nb">null?</span>  <span class="nv">tree</span><span class="p">)</span> <span class="no">#f</span><span class="p">)</span>
		                <span class="p">((</span><span class="nb">pair?</span> <span class="nv">tree</span><span class="p">)</span>
		                   <span class="p">(</span><span class="nf">iter</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">tree</span><span class="p">))</span>
		                   <span class="p">(</span><span class="nf">iter</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">tree</span><span class="p">)))</span>
		                <span class="p">(</span><span class="k">else</span>
		                  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eqv?</span> <span class="nv">obj</span> <span class="nv">tree</span><span class="p">)</span>
		                    <span class="p">(</span><span class="nf">cc</span> <span class="nv">obj</span><span class="p">)))))))</span>
         <span class="p">(</span><span class="nf">iter</span> <span class="nv">tree</span><span class="p">)))))</span>
</pre></div>
</div>
<div class="codeblock"><div class="highlight type-scheme"><pre><span class="p">(</span><span class="nf">find-leaf</span> <span class="mi">7</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="p">(</span><span class="nf">2</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">4</span> <span class="p">(</span><span class="nf">5</span> <span class="p">(</span><span class="nf">6</span> <span class="mi">7</span><span class="p">))))</span>
<span class="c1">;⇒ 7</span>

<span class="p">(</span><span class="nf">find-leaf</span> <span class="mi">8</span> <span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="p">(</span><span class="nf">2</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">4</span> <span class="p">(</span><span class="nf">5</span> <span class="p">(</span><span class="nf">6</span> <span class="mi">7</span><span class="p">))))</span>
<span class="c1">;⇒ ()</span>
</pre></div>
</div>
<p><strong>例6</strong>演示了一个支持抛出的语法<code>block</code>。</p>

<div class="codeblock"><div class="highlight type-scheme"><pre><span class="p">(</span><span class="k">define-syntax</span> <span class="nv">block</span>
  <span class="p">(</span><span class="k">syntax-rules</span> <span class="p">()</span>
    <span class="p">((</span><span class="nf">_</span> <span class="nv">tag</span> <span class="nv">e1</span> <span class="o">...</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">call-with-current-continuation</span>
       <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">tag</span><span class="p">)</span>
	      <span class="nv">e1</span> <span class="o">...</span><span class="p">)))))</span>
</pre></div>
</div>
<p><strong>例7</strong>演示了如何使用它。</p>

<div class="codeblock"><div class="highlight type-scheme"><pre><span class="p">(</span><span class="nf">block</span> <span class="nv">break</span>
   <span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span>
           <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">positive?</span> <span class="nv">x</span><span class="p">)</span>
	       <span class="p">(</span><span class="nb">sqrt</span> <span class="nv">x</span><span class="p">)</span>
	       <span class="p">(</span><span class="nf">break</span> <span class="nv">x</span><span class="p">)))</span>
	<span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)))</span>
<span class="c1">;⇒ (1 1.4142135623730951 1.7320508075688772)</span>

<span class="p">(</span><span class="nf">block</span> <span class="nv">break</span>
   <span class="p">(</span><span class="nb">map</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span>
           <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">positive?</span> <span class="nv">x</span><span class="p">)</span>
	       <span class="p">(</span><span class="nb">sqrt</span> <span class="nv">x</span><span class="p">)</span>
	       <span class="p">(</span><span class="nf">break</span> <span class="nv">x</span><span class="p">)))</span>
	<span class="o">'</span><span class="p">(</span><span class="nf">1</span> <span class="mi">-2</span> <span class="mi">3</span><span class="p">)))</span>
<span class="c1">;⇒ -2</span>
</pre></div>
</div>
<h3 id='section-16-4-2'><span>16.4.2</span> 生成器</h3>


<p>我会讲解如何用<code>call/cc</code>实现一个树匹配的生成器。生成器以一个树为参数返回一个函数，每次调用这个返回的函数时，它会返回后序的叶子。你可以在<a href="www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme-Z-H-15.html#node_sec_13.3">Teach Yourself Scheme in Fixnum Days的第13.3节</a>中找到这个函数的原始版本。生成器是像下面这样使用的：</p>

<div class="codeblock"><div class="highlight type-scheme"><pre><span class="p">(</span><span class="k">define</span> <span class="nv">tr</span> <span class="o">'</span><span class="p">((</span><span class="nf">1</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">3</span> <span class="p">(</span><span class="nf">4</span> <span class="mi">5</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">p</span> <span class="p">(</span><span class="nf">leaf-generator</span> <span class="nv">tr</span><span class="p">))</span>

<span class="p">(</span><span class="nf">p</span><span class="p">)</span> <span class="c1">;=&gt; 1</span>
<span class="p">(</span><span class="nf">p</span><span class="p">)</span> <span class="c1">;=&gt; 2</span>
<span class="p">(</span><span class="nf">p</span><span class="p">)</span> <span class="c1">;=&gt; 3</span>
<span class="p">(</span><span class="nf">p</span><span class="p">)</span> <span class="c1">;=&gt; 4</span>
<span class="p">(</span><span class="nf">p</span><span class="p">)</span> <span class="c1">;=&gt; 5</span>
<span class="p">(</span><span class="nf">p</span><span class="p">)</span> <span class="c1">;=&gt; ()  ; finally it returns '()</span>
</pre></div>
</div>
<p><strong>代码片段6</strong>给出了生成器的定义。这个和原始版本基本上相同，但有略微的修改。</p>

<div class="codeblock"><div class="highlight type-scheme"><pre><span class="mi">01</span><span class="nv">:</span>  <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">leaf-generator</span> <span class="nv">tree</span><span class="p">)</span>
<span class="mi">02</span><span class="nv">:</span>    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">return</span> <span class="o">'</span><span class="p">()))</span>            <span class="c1">;1</span>
<span class="mi">03</span><span class="nv">:</span>      <span class="p">(</span><span class="k">letrec</span> <span class="p">((</span><span class="nf">continue</span>           <span class="c1">;2</span>
<span class="mi">04</span><span class="nv">:</span>  	      <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span>
<span class="mi">05</span><span class="nv">:</span>  		    <span class="p">(</span><span class="k">let</span> <span class="nv">rec</span> <span class="p">((</span><span class="nf">tree</span> <span class="nv">tree</span><span class="p">))</span> <span class="c1">;3</span>
<span class="mi">06</span><span class="nv">:</span>  		     <span class="p">(</span><span class="k">cond</span>                 <span class="c1">;4</span>
<span class="mi">07</span><span class="nv">:</span>     	      <span class="p">((</span><span class="nb">null?</span> <span class="nv">tree</span><span class="p">)</span> <span class="ss">'skip</span><span class="p">)</span> <span class="c1">;5</span>
<span class="mi">08</span><span class="nv">:</span>               <span class="p">((</span><span class="nb">pair?</span> <span class="nv">tree</span><span class="p">)</span> <span class="p">(</span><span class="nf">rec</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">tree</span><span class="p">))</span> <span class="p">(</span><span class="nf">rec</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">tree</span><span class="p">)))</span><span class="c1">;6</span>
<span class="mi">09</span><span class="nv">:</span>     		   <span class="p">(</span><span class="k">else</span>                                           <span class="c1">;7</span>
<span class="mi">10</span><span class="nv">:</span>     		    <span class="p">(</span><span class="nb">call/cc</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">lap-to-go</span><span class="p">)</span>                   <span class="c1">;8</span>
<span class="mi">11</span><span class="nv">:</span>     			   <span class="p">(</span><span class="k">set!</span> <span class="nv">continue</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span> <span class="p">(</span><span class="nf">lap-to-go</span> <span class="ss">'restart</span><span class="p">)))</span><span class="c1">;9</span>
<span class="mi">12</span><span class="nv">:</span>     			   <span class="p">(</span><span class="nf">return</span> <span class="nv">tree</span><span class="p">))))))</span> <span class="c1">;10</span>
<span class="mi">13</span><span class="nv">:</span>     	   <span class="p">(</span><span class="nf">return</span> <span class="o">'</span><span class="p">()))))</span>            <span class="c1">;11</span>
<span class="mi">14</span><span class="nv">:</span>         <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span>                    <span class="c1">;12</span>
<span class="mi">15</span><span class="nv">:</span>            <span class="p">(</span><span class="nb">call/cc</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">where-to-go</span><span class="p">)</span>       <span class="c1">;13</span>
<span class="mi">16</span><span class="nv">:</span>                       <span class="p">(</span><span class="k">set!</span> <span class="nv">return</span> <span class="nv">where-to-go</span><span class="p">)</span> <span class="c1">;14</span>
<span class="mi">17</span><span class="nv">:</span>                       <span class="p">(</span><span class="nf">continue</span><span class="p">)))))))</span>
</pre></div>
</div>
<p>(译者注：原文中05，08行中命名let中的<code>rec</code>被写为<code>loop</code>，结合上下文，改为<code>rec</code>)</p>

<p>注释解释</p>

<p>编号  解释</p>

<ul>
  <li>1.定义本地变量<code>return</code>。</li>
  <li>2.使用<code>letrec</code>定义<code>continue</code>。<code>continue</code>将当前叶子返回到前面，将当前继续赋给<code>continue</code>，并停止。</li>
  <li>3.用<code>rec</code>定义命名let。 </li>
  <li>4.使用<code>cond</code>实现分支</li>
  <li>5.如果是空表，什么也不做</li>
  <li>6.如果是序对，递归地对序对的car和cdr进行调用rec。</li>
  <li>7.如果是叶子，</li>
  <li>8.调用<code>call/cc</code>以获取当前状态(lap-to-go)</li>
  <li>9.接着将当前状态赋给<code>continue</code>，所以除了原有的<code>continue</code>，<code>lap-to-go</code>包含了当前状态。简而言之，它可以被如下的S-表达式中的<strong>[ ]</strong>表示。</li>
</ul>

<div class="codeblock"><div class="highlight type-plaintext"><pre>(lambda ()
   (let rec ((tree tree0))  
      (cond                  
        ((null? tree) '())     
        ((pair? tree) (rec (car tree)) (rec (cdr tree)))  
        (else                                             
           [ ]                    
    (return '()))))
</pre></div>
</div>
<p>调用<code>lap-to-go</code>意味着(car tree)是叶子，且过程结束了，(rec (cdr tree))在下一次函数调用时开始运行。如果过程在<strong>[ ]</strong>之后结束，继续的参数将不起作用。                           </p>

<ul>
  <li>10.接着函数将找到的叶子返回到函数的调用处。<code>(return tree)</code>应该在<code>call/cc</code>中以重启过程。</li>
  <li>11.在搜索了全部叶子之后返回空表。</li>
  <li>12.这是一个返回叶子生成器的生成器。</li>
  <li>13.首次调用<code>call/cc</code></li>
  <li>14.将表示返回值的当前状态赋给<code>return</code>。</li>
  <li>15.然后调用<code>continue</code>。</li>
</ul>

<p>由<code>leaf-generator</code>生成的函数的行为可以通过函数（tree-traverse）的行为来估计。过程停止在轨迹的’*‘的注释处，并使得过程存储在<code>continue</code>。
 一个常规的便利函数：</p>

<div class="codeblock"><div class="highlight type-scheme"><pre><span class="p">(</span><span class="k">define</span> <span class="nv">tree-traverse</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">tree</span><span class="p">)</span>
    <span class="p">(</span><span class="k">cond</span>
     <span class="p">((</span><span class="nb">null?</span> <span class="nv">tree</span><span class="p">)</span> <span class="ss">'_</span><span class="p">)</span>
     <span class="p">((</span><span class="nb">pair?</span> <span class="nv">tree</span><span class="p">)</span> <span class="p">(</span><span class="nf">tree-traverse</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">tree</span><span class="p">))</span> <span class="p">(</span><span class="nf">tree-traverse</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">tree</span><span class="p">)))</span>
     <span class="p">(</span><span class="k">else</span>
      <span class="p">(</span><span class="nb">write</span> <span class="nv">tree</span><span class="p">)))))</span>
</pre></div>
</div>
<p>当树为<code>'((1 2) 3)</code>时，<code>tree-traverse</code>的轨迹。</p>

<div class="codeblock"><div class="highlight type-plaintext"><pre>&gt; (tree-traverse '((1 2) 3))
|(tree-traverse ((1 2) 3))
| (tree-traverse (1 2))
| |(tree-traverse 1)           
1| |#&lt; void&gt;               ; *
| (tree-traverse (2))
| |(tree-traverse 2)           
2| |&lt; void&gt;                ; *
| (tree-traverse '())
| _
|(tree-traverse (3))
| (tree-traverse 3)            
3| #&lt; void&gt;                ; *
|(tree-traverse '())
|_
_
</pre></div>
</div>
<h3 id='section-16-4-3'><span>16.4.3</span> 协程</h3>


<p>因为继续记录了后续计算过程，因此，用于多任务同时执行的<strong>协程（Coroutine）</strong>可以使用继续来实现。</p>

<p><strong>代码片段7</strong>展示了一段交替打印数字和字母的程序。5 - 22行是队列的实现。(enqueue! queue obj)将一个<code>obj</code>添加在队列的末尾。(dequeue! queue)返回队列第一个元素并将它删除。</p>

<p>26 - 38行是协程的实现。</p>

<p>
  <strong>process-queue</strong>
</p>

<p>过程的队列。</p>

<p>
  <strong>(coroutine thunk)</strong>
</p>

<p>在<code>process-queue</code>末尾添加<code>thunk</code>。</p>

<p>
  <strong>(start)</strong>
</p>

<p>取得<code>process-queue</code>的第一个过程并执行它。</p>

<p>
  <strong>(pause)</strong>
</p>

<p>将当前继续添加到<code>process-queue</code>的末尾并执行队列里的第一个过程。这个函数将控制权交给另外一个协程。</p>

<p>42 - 61行显示如何使用它。一个显示数字例程和一个显示字母例程相互调用对方，结果显示在<strong>例7</strong></p>

<div class="codeblock"><div class="highlight type-scheme"><pre><span class="mi">01</span><span class="nv">:</span>     <span class="c1">;;; abbreviation</span>
<span class="mi">02</span><span class="nv">:</span>     <span class="p">(</span><span class="k">define</span> <span class="nv">call/cc</span> <span class="nv">call-with-current-continuation</span><span class="p">)</span>
<span class="mi">03</span><span class="nv">:</span>     
<span class="mi">04</span><span class="nv">:</span>     <span class="c1">;;; queue</span>
<span class="mi">05</span><span class="nv">:</span>     <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">make-queue</span><span class="p">)</span>
<span class="mi">06</span><span class="nv">:</span>       <span class="p">(</span><span class="nb">cons</span> <span class="o">'</span><span class="p">()</span> <span class="o">'</span><span class="p">()))</span>
<span class="mi">07</span><span class="nv">:</span>     
<span class="mi">08</span><span class="nv">:</span>     <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">enqueue!</span> <span class="nv">queue</span> <span class="nv">obj</span><span class="p">)</span>
<span class="mi">09</span><span class="nv">:</span>       <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">lobj</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">obj</span><span class="p">)))</span>
<span class="mi">10</span><span class="nv">:</span>         <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null?</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">queue</span><span class="p">))</span>
<span class="mi">11</span><span class="nv">:</span>     	<span class="p">(</span><span class="k">begin</span>
<span class="mi">12</span><span class="nv">:</span>     	  <span class="p">(</span><span class="nb">set-car!</span> <span class="nv">queue</span> <span class="nv">lobj</span><span class="p">)</span>
<span class="mi">13</span><span class="nv">:</span>     	  <span class="p">(</span><span class="nb">set-cdr!</span> <span class="nv">queue</span> <span class="nv">lobj</span><span class="p">))</span>
<span class="mi">14</span><span class="nv">:</span>     	<span class="p">(</span><span class="k">begin</span>
<span class="mi">15</span><span class="nv">:</span>     	  <span class="p">(</span><span class="nb">set-cdr!</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">queue</span><span class="p">)</span> <span class="nv">lobj</span><span class="p">)</span>
<span class="mi">16</span><span class="nv">:</span>     	  <span class="p">(</span><span class="nb">set-cdr!</span> <span class="nv">queue</span> <span class="nv">lobj</span><span class="p">)))</span>
<span class="mi">17</span><span class="nv">:</span>         <span class="p">(</span><span class="nb">car</span> <span class="nv">queue</span><span class="p">)))</span>
<span class="mi">18</span><span class="nv">:</span>     
<span class="mi">19</span><span class="nv">:</span>     <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">dequeue!</span> <span class="nv">queue</span><span class="p">)</span>
<span class="mi">20</span><span class="nv">:</span>       <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">obj</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">queue</span><span class="p">))))</span>
<span class="mi">21</span><span class="nv">:</span>         <span class="p">(</span><span class="nb">set-car!</span> <span class="nv">queue</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">queue</span><span class="p">)))</span>
<span class="mi">22</span><span class="nv">:</span>         <span class="nv">obj</span><span class="p">))</span>
<span class="mi">23</span><span class="nv">:</span>     
<span class="mi">24</span><span class="nv">:</span>     
<span class="mi">25</span><span class="nv">:</span>     <span class="c1">;;; coroutine   </span>
<span class="mi">26</span><span class="nv">:</span>     <span class="p">(</span><span class="k">define</span> <span class="nv">process-queue</span> <span class="p">(</span><span class="nf">make-queue</span><span class="p">))</span>
<span class="mi">27</span><span class="nv">:</span>     
<span class="mi">28</span><span class="nv">:</span>     <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">coroutine</span> <span class="nv">thunk</span><span class="p">)</span>
<span class="mi">29</span><span class="nv">:</span>       <span class="p">(</span><span class="nf">enqueue!</span> <span class="nv">process-queue</span> <span class="nv">thunk</span><span class="p">))</span>
<span class="mi">30</span><span class="nv">:</span>     
<span class="mi">31</span><span class="nv">:</span>     <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">start</span><span class="p">)</span>
<span class="mi">32</span><span class="nv">:</span>        <span class="p">((</span><span class="nf">dequeue!</span> <span class="nv">process-queue</span><span class="p">)))</span>
<span class="mi">33</span><span class="nv">:</span>        
<span class="mi">34</span><span class="nv">:</span>     <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">pause</span><span class="p">)</span>
<span class="mi">35</span><span class="nv">:</span>       <span class="p">(</span><span class="nb">call/cc</span>
<span class="mi">36</span><span class="nv">:</span>        <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">k</span><span class="p">)</span>
<span class="mi">37</span><span class="nv">:</span>          <span class="p">(</span><span class="nf">coroutine</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span> <span class="p">(</span><span class="nf">k</span> <span class="no">#f</span><span class="p">)))</span>
<span class="mi">38</span><span class="nv">:</span>          <span class="p">(</span><span class="nf">start</span><span class="p">))))</span>
<span class="mi">39</span><span class="nv">:</span>     
<span class="mi">40</span><span class="nv">:</span>     
<span class="mi">41</span><span class="nv">:</span>     <span class="c1">;;; example</span>
<span class="mi">42</span><span class="nv">:</span>     <span class="p">(</span><span class="nf">coroutine</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span>
<span class="mi">43</span><span class="nv">:</span>     	     <span class="p">(</span><span class="k">let</span> <span class="nv">loop</span> <span class="p">((</span><span class="nf">i</span> <span class="mi">0</span><span class="p">))</span> 
<span class="mi">44</span><span class="nv">:</span>     	       <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">i</span> <span class="mi">10</span><span class="p">)</span>
<span class="mi">45</span><span class="nv">:</span>     		   <span class="p">(</span><span class="k">begin</span>
<span class="mi">46</span><span class="nv">:</span>     		     <span class="p">(</span><span class="nb">display</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">i</span><span class="p">))</span> 
<span class="mi">47</span><span class="nv">:</span>     		     <span class="p">(</span><span class="nb">display</span> <span class="s">" "</span><span class="p">)</span> 
<span class="mi">48</span><span class="nv">:</span>     		     <span class="p">(</span><span class="nf">pause</span><span class="p">)</span> 
<span class="mi">49</span><span class="nv">:</span>     		     <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">i</span><span class="p">)))))))</span>
<span class="mi">50</span><span class="nv">:</span>     		   
<span class="mi">51</span><span class="nv">:</span>     <span class="p">(</span><span class="nf">coroutine</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">()</span>
<span class="mi">52</span><span class="nv">:</span>     	     <span class="p">(</span><span class="k">let</span> <span class="nv">loop</span> <span class="p">((</span><span class="nf">i</span> <span class="mi">0</span><span class="p">))</span> 
<span class="mi">53</span><span class="nv">:</span>     	       <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">i</span> <span class="mi">10</span><span class="p">)</span>
<span class="mi">54</span><span class="nv">:</span>     		   <span class="p">(</span><span class="k">begin</span>
<span class="mi">55</span><span class="nv">:</span>     		     <span class="p">(</span><span class="nb">display</span> <span class="p">(</span><span class="nb">integer-&gt;char</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">i</span> <span class="mi">97</span><span class="p">)))</span>
<span class="mi">56</span><span class="nv">:</span>     		     <span class="p">(</span><span class="nb">display</span> <span class="s">" "</span><span class="p">)</span>
<span class="mi">57</span><span class="nv">:</span>     		     <span class="p">(</span><span class="nf">pause</span><span class="p">)</span> 
<span class="mi">58</span><span class="nv">:</span>     		     <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">i</span><span class="p">)))))))</span>
<span class="mi">59</span><span class="nv">:</span>     
<span class="mi">60</span><span class="nv">:</span>     <span class="p">(</span><span class="nb">newline</span><span class="p">)</span>
<span class="mi">61</span><span class="nv">:</span>     <span class="p">(</span><span class="nf">start</span><span class="p">)</span>
</pre></div>
</div>
<div class="codeblock"><div class="highlight type-scheme"><pre><span class="p">(</span><span class="nb">load</span> <span class="s">"cor2.scm"</span><span class="p">)</span>
<span class="c1">;Loading "cor2.scm"</span>
<span class="mi">1</span> <span class="nv">a</span> <span class="mi">2</span> <span class="nv">b</span> <span class="mi">3</span> <span class="nv">c</span> <span class="mi">4</span> <span class="nv">d</span> <span class="mi">5</span> <span class="nv">e</span> <span class="mi">6</span> <span class="nv">f</span> <span class="mi">7</span> <span class="nv">g</span> <span class="mi">8</span> <span class="nv">h</span> <span class="mi">9</span> <span class="nv">i</span> <span class="mi">10</span> <span class="nv">j</span>  <span class="nv">--</span> <span class="nv">done</span>
<span class="c1">;Unspecified return value</span>
</pre></div>
</div>
<h2 id='section-16-5'><span>16.5</span> 总结</h2>


<p>本章中，我讲解了继续。</p>

<p>理解这些概念可能比较困难。但不要担心，有朝一日你终会明白。</p>

<p>下一章中，我将介绍惰性求值。</p>

  	</div>
</div>

		
			
			<div class="navigation">
				
					<a class="prev_page" href="./chapter15.html">&laquo; 第 15 章定义语法</a>
				
				
			</div>
			
    </div>		
	</div>
</body>
</html>
